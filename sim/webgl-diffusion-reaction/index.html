<!DOCTYPE html>
<meta charset="utf-8">
<title>Diffusion Reaction Modell using WebGL</title>

<style>
	body { font-family: sans-serif; background-color: black;}
	canvas { display: block; margin: auto; background-color: black;}
	#fail { color: red; white-space: pre-wrap; max-width: 600px; }
</style>

<!-- WEBGL SHADERS -->
<script type="x-webgl/x-vertex-shader" id="vertex-shader">#version 300 es

in vec2 a_position;

void main() {
	gl_Position = vec4(a_position, 0, 1);
}
</script>

<script type="x-webgl/x-fragment-shader" id="timestep-shader">#version 300 es

precision mediump float;
uniform sampler2D u_image;
uniform vec2 u_size;
uniform vec4 inpv;

out vec4 myOutputColor;
// const float F = 0.0545, K = 0.062,
// 	D_a = 0.20, D_b = 0.10;
const float TIMESTEP = 1.09;

float F,K,D_a,D_b;

void main() {
    
    F = inpv[0];
    K = inpv[1];
    D_a = inpv[2];
    D_b = inpv[3];

	vec2 p = gl_FragCoord.xy,
	     n = p + vec2(0.0, 1.0),
	     e = p + vec2(1.0, 0.0),
	     s = p + vec2(0.0, -1.0),
	     w = p + vec2(-1.0, 0.0);

	vec2 val = texture(u_image, p / u_size).xy,
	     laplacian = texture(u_image, n / u_size).xy
		+ texture(u_image, e / u_size).xy
		+ texture(u_image, s / u_size).xy
		+ texture(u_image, w / u_size).xy
		- 4.0 * val;

	vec2 delta = vec2(D_a * laplacian.x - val.x*val.y*val.y + F * (1.0-val.x),
		D_b * laplacian.y + val.x*val.y*val.y - (K+F) * val.y);

	myOutputColor  = vec4(val + delta * TIMESTEP, 0, 0);
}
</script>

<script type="x-webgl/x-fragment-shader" id="render-shader">#version 300 es

precision mediump float;
uniform sampler2D u_image;
uniform vec2 u_size;

out vec4 myOutputColor;

const float COLOR_MIN = 0.1, COLOR_MAX = 0.48;

void main() {
	float v = (texture(u_image, gl_FragCoord.xy / u_size).y) / (COLOR_MAX - COLOR_MIN);


	myOutputColor = vec4(v, v, v, 1)*vec4(0.35,1.2,0.38,0.70);
}
</script>
<!-- HTML Elements / GUI -->
<body>
<button id="bttn1">Random Parameters</button>
<input id="sliderF" type="range" min="0.0400" max="0.0775" step="0.00015" />
<input id="rangeValueF" type="text" size="14">
<input id="sliderK" type="range" min="0.0550" max="0.075" step="0.00015" />
<input id="rangeValueK" type="text" size="14">

<input id="sliderD_a" type="range" min="0.1" max="0.3" step="0.001" />
<input id="rangeValueD_a" type="text" size="14">
<input id="sliderD_b" type="range" min="0.01" max="0.2" step="0.001" />
<input id="rangeValueD_b" type="text" size="14">


<!-- Computation and Control -->
<script>
"use strict";
let W = 1400, H = 800;
let canvas,gl;
let vertex_shader,timestep_shader,render_shader,timestep_prog,render_prog;
let F,K,D_a,D_b;
let loop=true;

function init() {
	canvas = document.createElement("canvas");

	canvas.id = "canvas";
	canvas.width = W;
	canvas.height = H;
	document.body.appendChild(canvas);

	gl = canvas.getContext("webgl2");
	//checkCompatibility(gl);

    let ext = gl.getExtension('EXT_color_buffer_float');
    
	vertex_shader = createShader(gl, gl.VERTEX_SHADER, "vertex-shader");
	timestep_shader = createShader(gl, gl.FRAGMENT_SHADER, "timestep-shader");
	render_shader = createShader(gl, gl.FRAGMENT_SHADER, "render-shader");
	timestep_prog = createAndLinkProgram(gl, vertex_shader, timestep_shader);
	render_prog = createAndLinkProgram(gl, vertex_shader, render_shader);
	gl.useProgram(render_prog);

	init2();
}

function init2() {

	loadVertexData(gl, render_prog);
	gl.uniform2f(gl.getUniformLocation(render_prog, "u_size"), W, H);

	gl.useProgram(timestep_prog);
	loadVertexData(gl, timestep_prog);
	gl.uniform2f(gl.getUniformLocation(timestep_prog, "u_size"), W, H);

	 F = 0.0575+(Math.random()-0.5)/30; 
	 K = 0.062+(Math.random()-0.5)/110;
	 D_a = 0.21+(Math.random()-0.5)/50; 
	 D_b = 0.115+(Math.random()-0.5)/50;
	 // F = 0.0482912165066033;
	 // K = 0.060443647371791545;
	 // D_a = 0.2043522177008882;
	 // D_b = 0.11710375974982423;

	gl.uniform4f(gl.getUniformLocation(timestep_prog, "inpv"), F,K,D_a,D_b);

	console.table([["F","K","D_a","D_b"],[F,K,D_a,D_b]]);

	let initial_state = getInitialState();
	let t1 = newTexture(gl, initial_state),
	    t2 = newTexture(gl, null),
	    fb1 = newFramebuffer(gl, t1),
	    fb2 = newFramebuffer(gl, t2);

	// Check the hardware can render to a float framebuffer
	// (https://developer.mozilla.org/en-US/docs/Web/WebGL/WebGL_best_practices)
	gl.useProgram(timestep_prog);
	gl.bindFramebuffer(gl.FRAMEBUFFER, fb1);
	let fb_status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
	if (fb_status != gl.FRAMEBUFFER_COMPLETE) {
		fail("Cannot render to framebuffer: " + fb_status);
	}

	function step() {
		gl.useProgram(timestep_prog);
		for (let i=0; i<10; i++) {
			gl.bindTexture(gl.TEXTURE_2D, [t1, t2][i % 2]);
			gl.bindFramebuffer(gl.FRAMEBUFFER, [fb2, fb1][i % 2]);
			gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
		}

		gl.useProgram(render_prog);
		gl.bindTexture(gl.TEXTURE_2D, t1);
		gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
		if (loop){
			requestAnimationFrame(step);
		}
	}

    // start continous Animation
	loop=true;
	requestAnimationFrame(step);

	//GUI-Adjust
 	document.getElementById("sliderF").value=F;
    document.getElementById("rangeValueF").value="F="+F;
    document.getElementById("sliderK").value=K;
    document.getElementById("rangeValueK").value="K="+K;
    document.getElementById("sliderD_a").value=D_a;
    document.getElementById("rangeValueD_a").value="D_a="+D_a;
    document.getElementById("sliderD_b").value=D_b;
    document.getElementById("rangeValueD_b").value="D_b="+D_b;
}

function getInitialState() {
	let a = new Float32Array(4 * W * H);

	for (let y=0; y<H; y++) {
		for (let x=0; x<W; x++) {
			let i = W*y + x;
			let central_square = (x > W/2-10 && x < W/2 + 10 && y > H/2-10 && y < H/2+10);
			if (central_square) {
				a[4*i + 0] = 0.7 + Math.random() * 0.02 - 0.01;
				a[4*i + 1] = 0.25 + Math.random() * 0.03 - 0.01; //0.02
			} else {
				a[4*i + 0] = 1.0;
				a[4*i + 1] = 0;
			}
		}
	}
	return a;
}

// Create, initialise, and bind a new texture
function newTexture(gl, initial_state) {
	let texture = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D, texture);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
	//gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, W, H, 0, gl.RGBA, gl.FLOAT, initial_state);
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, W, H, 0, gl.RGBA, gl.FLOAT, initial_state);
	return texture;
}

function newFramebuffer(gl, texture) {
	let fb = gl.createFramebuffer();
	gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
	gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
	return fb;
}

function loadVertexData(gl, prog) {
	gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([ -1,-1, 1,-1, -1,1, 1,1 ]), gl.STATIC_DRAW);

	let a_position = gl.getAttribLocation(prog, "a_position");
	gl.enableVertexAttribArray(a_position);
	gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
}

function createAndLinkProgram(gl, vertex_shader, fragment_shader) {
	let prog = gl.createProgram();
	gl.attachShader(prog, vertex_shader);
	gl.attachShader(prog, fragment_shader);
	gl.linkProgram(prog);
	if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
		fail("Failed to link program: " + gl.getProgramInfoLog(prog));
	}
	return prog;
}

function createShader(gl, shader_type, shader_code_id) {
	let shader = gl.createShader(shader_type);
	gl.shaderSource(shader, document.getElementById(shader_code_id).text);
	gl.compileShader(shader);
	if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
		let err = gl.getShaderInfoLog(shader);
		fail("Failed to compile shader: " + err);
	}
	return shader
}

function fail(message) {
	let fail = document.createElement("p");
	fail.id = "fail";
	fail.appendChild(document.createTextNode(message));
	document.body.removeChild(document.getElementById("canvas"));
	document.body.appendChild(fail);
	throw message;
}

function webglApplyParam() {
	gl.useProgram(timestep_prog);
	loadVertexData(gl, timestep_prog);
	gl.uniform2f(gl.getUniformLocation(timestep_prog, "u_size"), W, H);
	gl.uniform4f(gl.getUniformLocation(timestep_prog, "inpv"), F,K,D_a,D_b);
}

init();

// Event-Listener Random Button
document.getElementById("bttn1").addEventListener("click", () => {loop=false;
    setTimeout(function(){ init2(); }, 150);});

// Event-Listener Slider Feed
document.getElementById("sliderF").addEventListener("change", () => {
	document.getElementById("rangeValueF").value="F= "+document.getElementById("sliderF").value;
    F=parseFloat(document.getElementById("sliderF").value);
    webglApplyParam();
});

// Event-Listener Slider Kill
document.getElementById("sliderK").addEventListener("change", () => {
	document.getElementById("rangeValueK").value="K= "+document.getElementById("sliderK").value;
    K=parseFloat(document.getElementById("sliderK").value);
    webglApplyParam();
});

// Event-Listener Slider D_a
document.getElementById("sliderD_a").addEventListener("change", () => {
	document.getElementById("rangeValueD_a").value="D_a= "+document.getElementById("sliderD_a").value;
    D_a=parseFloat(document.getElementById("sliderD_a").value);
    webglApplyParam();
});

// Event-Listener Slider D_b
document.getElementById("sliderD_b").addEventListener("change", () => {
	document.getElementById("rangeValueD_b").value="D_b= "+document.getElementById("sliderD_b").value;
    D_b=parseFloat(document.getElementById("sliderD_b").value);
    webglApplyParam();
});
</script>

</body>